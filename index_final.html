<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>凸透镜成像虚拟实验课（Final）</title>
  <style>
    :root {
      color-scheme: light;
      --bg-color: #f7f8fa;
      --card-bg: #ffffff;
      --primary: #1c3d74;
      --primary-soft: rgba(28, 61, 116, 0.1);
      --text: #2a2a2a;
      --muted: #6c7a89;
      --real: #1e6ffb;
      --virtual: #ff8a00;
      --success: #2b8a3e;
      --danger: #d9480f;
      --stage-bg: #f9fcff;
      --border: rgba(28, 61, 116, 0.12);
      --quiz-border: rgba(28, 61, 116, 0.2);
    }

    *, *::before, *::after {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Segoe UI", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
      background: var(--bg-color);
      color: var(--text);
      line-height: 1.6;
      font-size: 16px;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header,
    footer {
      background: #ffffff;
      border-bottom: 1px solid var(--border);
      padding: 16px 24px;
      box-shadow: 0 2px 8px rgba(28, 61, 116, 0.08);
    }

    footer {
      border-bottom: none;
      border-top: 1px solid var(--border);
      box-shadow: 0 -2px 8px rgba(28, 61, 116, 0.08);
      text-align: center;
      font-size: 15px;
      color: var(--muted);
    }

    header h1 {
      margin: 0;
      font-size: 26px;
      color: var(--primary);
      letter-spacing: 0.5px;
    }

    header p {
      margin: 6px 0 0;
      color: var(--muted);
    }

    main.layout {
      display: grid;
      grid-template-columns: 280px 1fr 300px;
      gap: 20px;
      padding: 20px 24px 32px;
      flex: 1;
      height: calc(100vh - 120px);
    }

    #controls,
    #info {
      overflow-y: auto;
      padding: 1rem;
      background: var(--card-bg);
      border-radius: 16px;
      box-shadow: 0 8px 24px rgba(28, 61, 116, 0.12);
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    #stage-container {
      position: relative;
      min-height: 420px;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      background: var(--stage-bg);
      border-radius: 18px;
      box-shadow: inset 0 0 0 1px rgba(30, 111, 251, 0.08), 0 8px 24px rgba(28, 61, 116, 0.12);
    }

    #stage-container::after {
      content: attr(data-mode-label);
      position: absolute;
      top: 14px;
      right: 16px;
      font-weight: 600;
      font-size: 15px;
      color: rgba(28, 61, 116, 0.7);
    }

    #mode-ui {
      position: absolute;
      bottom: 12px;
      width: 100%;
      text-align: center;
      z-index: 3;
      pointer-events: auto;
      padding: 0 16px;
    }

    #mode-ui .content {
      max-height: 140px;
      overflow-y: auto;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 8px;
      padding: 0.5rem 1rem;
      display: inline-block;
      text-align: left;
      box-shadow: 0 6px 16px rgba(28, 61, 116, 0.16);
    }

    svg#lens-svg {
      max-width: 100%;
      height: auto;
      display: block;
    }

    #stage-hud {
      position: absolute;
      left: 16px;
      top: 16px;
      z-index: 2;
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-width: 260px;
    }

    #mode-guide {
      margin: 0;
      font-size: 15px;
      color: var(--muted);
      background: rgba(255, 255, 255, 0.9);
      padding: 6px 10px;
      border-radius: 6px;
    }

    #status-text {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
      color: var(--primary);
      background: rgba(255, 255, 255, 0.95);
      padding: 6px 10px;
      border-radius: 6px;
      box-shadow: inset 0 0 0 1px rgba(28, 61, 116, 0.08);
    }

    #status-text.warning {
      color: var(--danger);
    }

    #status-text.positive {
      color: var(--success);
    }

    .hint {
      margin: -4px 0 0;
      color: var(--muted);
      font-size: 15px;
    }

    #mode-tabs {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .mode-tab {
      border: none;
      background: rgba(28, 61, 116, 0.12);
      color: var(--primary);
      padding: 8px 16px;
      border-radius: 999px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s, transform 0.2s;
    }

    .mode-tab[aria-selected="true"],
    .mode-tab.active {
      background: var(--primary);
      color: #ffffff;
      transform: translateY(-1px);
    }

    .mode-tab:focus {
      outline: 2px solid var(--primary);
      outline-offset: 2px;
    }

    .control-item,
    .toggle-wrapper,
    .select-wrapper {
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 14px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(247, 248, 250, 0.7);
    }

    .control-item label,
    .select-wrapper label,
    .toggle-wrapper span {
      font-weight: 600;
      font-size: 17px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }

    .control-item output,
    .select-wrapper output {
      min-width: 90px;
      text-align: right;
      font-variant-numeric: tabular-nums;
    }

    .control-item input[type="range"] {
      width: 100%;
      accent-color: var(--primary);
    }

    .select-wrapper select {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      font-size: 16px;
      background: #ffffff;
    }

    .switch {
      position: relative;
      width: 52px;
      height: 26px;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(28, 61, 116, 0.25);
      transition: 0.3s;
      border-radius: 24px;
    }

    .slider::before {
      position: absolute;
      content: "";
      height: 20px;
      width: 20px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    }

    .switch input:checked + .slider {
      background-color: rgba(28, 61, 116, 0.6);
    }

    .switch input:checked + .slider::before {
      transform: translateX(26px);
    }

    .helper {
      color: var(--muted);
      font-size: 14px;
    }

    .info-card {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 16px;
      border-radius: 14px;
      background: rgba(255, 255, 255, 0.92);
      box-shadow: inset 0 0 0 1px rgba(28, 61, 116, 0.08);
    }

    .info-card h3 {
      margin: 0;
      font-size: 18px;
      color: var(--primary);
    }

    .info-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
      color: var(--text);
    }

    .info-list li {
      display: flex;
      justify-content: space-between;
      font-variant-numeric: tabular-nums;
      font-weight: 500;
    }

    .info-list li span.label {
      color: var(--muted);
      font-weight: 600;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 2px 10px;
      border-radius: 999px;
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 0.5px;
      background: var(--primary-soft);
      color: var(--primary);
      margin-right: 6px;
    }

    .badge.real {
      background: rgba(30, 111, 251, 0.15);
      color: var(--real);
    }

    .badge.virtual {
      background: rgba(255, 138, 0, 0.18);
      color: var(--virtual);
    }

    #image-nature {
      margin: 0;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    button {
      background: var(--primary);
      color: #ffffff;
      border: none;
      border-radius: 999px;
      padding: 10px 18px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      align-self: flex-start;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 12px rgba(28, 61, 116, 0.18);
    }

    button:focus {
      outline: 2px solid rgba(28, 61, 116, 0.5);
      outline-offset: 2px;
    }

    .dev-only {
      display: none;
      border: 1px dashed rgba(28, 61, 116, 0.4);
      background: rgba(28, 61, 116, 0.06);
      color: var(--primary);
      padding: 10px 14px;
      border-radius: 10px;
      font-weight: 600;
    }

    body.dev-mode .dev-only {
      display: inline-flex;
      align-self: flex-end;
    }

    .teacher-only {
      display: none;
    }

    body.teacher-mode .teacher-only {
      display: flex;
    }

    body.teacher-mode svg#lens-svg {
      background-image:
        linear-gradient(180deg, rgba(255, 255, 255, 0.9), rgba(230, 237, 250, 0.9)),
        linear-gradient(0deg, rgba(28, 61, 116, 0.12) 1px, transparent 1px),
        linear-gradient(90deg, rgba(28, 61, 116, 0.12) 1px, transparent 1px);
      background-size: cover, 40px 40px, 40px 40px;
    }

    .challenge-list {
      list-style: none;
      padding: 0;
      margin: 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .challenge-item {
      border: 1px dashed rgba(28, 61, 116, 0.3);
      border-radius: 12px;
      padding: 8px 10px;
      background: rgba(247, 248, 250, 0.7);
      font-size: 14px;
    }

    .challenge-item h4 {
      margin: 0 0 4px;
      font-size: 15px;
      color: var(--primary);
    }

    .challenge-item.passed {
      border-color: rgba(43, 138, 62, 0.6);
      background: rgba(43, 138, 62, 0.08);
    }

    .challenge-item .status {
      font-weight: 600;
    }

    .challenge-item.passed .status {
      color: var(--success);
    }

    .challenge-actions {
      margin-top: 8px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .quiz-question {
      border: 1px solid var(--quiz-border);
      border-radius: 12px;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      background: rgba(247, 248, 250, 0.6);
      font-size: 14px;
    }

    .quiz-question h4 {
      margin: 0;
      font-size: 15px;
      color: var(--primary);
    }

    .quiz-options {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .quiz-options label {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .quiz-feedback {
      font-weight: 600;
      color: var(--muted);
    }

    .quiz-feedback.correct {
      color: var(--success);
    }

    .quiz-feedback.incorrect {
      color: var(--danger);
    }

    .quiz-input {
      padding: 4px 6px;
      border-radius: 6px;
      border: 1px solid var(--border);
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      font-size: 14px;
    }

    th, td {
      border: 1px solid rgba(28, 61, 116, 0.16);
      padding: 4px 8px;
      text-align: center;
    }

    th {
      background: rgba(28, 61, 116, 0.1);
      color: var(--primary);
    }

    @media (max-width: 900px) {
      main.layout {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr auto;
        height: auto;
      }

      #controls,
      #info {
        max-height: 35vh;
      }

      #stage-container {
        min-height: 360px;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>凸透镜成像虚拟实验课</h1>
    <p>适用于课堂投影与移动端的互动 H5｜探索成像规律·完成挑战·通过测验</p>
  </header>

  <main class="layout">
    <aside id="controls" aria-labelledby="controls-title">
      <h2 id="controls-title">操作面板</h2>
      <p class="hint" id="mode-hint">拖动滑块看看会发生什么～</p>
      <nav id="mode-tabs" role="tablist" aria-label="教学模式切换">
        <button type="button" class="mode-tab" role="tab" aria-selected="true" data-mode="explore">探索</button>
        <button type="button" class="mode-tab" role="tab" aria-selected="false" data-mode="summary">规律总结</button>
        <button type="button" class="mode-tab" role="tab" aria-selected="false" data-mode="challenge">挑战</button>
        <button type="button" class="mode-tab" role="tab" aria-selected="false" data-mode="quiz">测验</button>
      </nav>

      <div class="control-item">
        <label for="u-range"><span>物距 <strong>u</strong></span><output id="u-display" for="u-range">18.0 cm</output></label>
        <input id="u-range" type="range" min="5" max="30" step="0.1" value="18" aria-describedby="u-helper">
        <small id="u-helper" class="helper">范围：5–30 cm</small>
      </div>

      <div class="control-item">
        <label for="f-range"><span>焦距 <strong>f</strong></span><output id="f-display" for="f-range">10.0 cm</output></label>
        <input id="f-range" type="range" min="5" max="15" step="0.1" value="10" aria-describedby="f-helper">
        <small id="f-helper" class="helper">范围：5–15 cm</small>
      </div>

      <div class="control-item">
        <label for="ho-range"><span>物高 <strong>ho</strong></span><output id="ho-display" for="ho-range">3.0 cm</output></label>
        <input id="ho-range" type="range" min="1" max="5" step="0.1" value="3" aria-describedby="ho-helper">
        <small id="ho-helper" class="helper">范围：1–5 cm</small>
      </div>

      <div class="select-wrapper">
        <label for="spriteSelect">物体类型：</label>
        <select id="spriteSelect">
          <option value="candle">蜡烛</option>
          <option value="person">小人</option>
          <option value="arrow">箭头</option>
        </select>
      </div>

      <div class="toggle-wrapper" role="group" aria-label="光线显示切换">
        <span>显示三条主光线</span>
        <label class="switch" aria-label="显示或隐藏光线">
          <input id="show-rays" type="checkbox" checked>
          <span class="slider" aria-hidden="true"></span>
        </label>
      </div>

      <div class="toggle-wrapper" role="group" aria-label="显示屏幕切换">
        <span>显示屏幕</span>
        <label class="switch" aria-label="显示或隐藏屏幕">
          <input id="show-screen" type="checkbox">
          <span class="slider" aria-hidden="true"></span>
        </label>
      </div>

      <div class="toggle-wrapper" role="group" aria-label="教师模式切换">
        <span>教师模式</span>
        <label class="switch" aria-label="开启或关闭教师模式">
          <input id="teacher-mode-toggle" type="checkbox">
          <span class="slider" aria-hidden="true"></span>
        </label>
      </div>

      <div class="control-item teacher-only" id="tolerance-control">
        <label for="tol-range"><span>判定容差 <strong>TOL</strong></span><output id="tol-display" for="tol-range">±0.5 cm</output></label>
        <input id="tol-range" type="range" min="0.1" max="1" step="0.1" value="0.5" aria-describedby="tol-helper">
        <small id="tol-helper" class="helper">范围：0.1–1.0 cm，可影响挑战判定严格程度</small>
      </div>

      <button type="button" id="self-test" class="dev-only">运行自检（开发专用）</button>
    </aside>

    <section id="stage-container" aria-labelledby="stage-title" data-mode-label="探索模式">
      <h2 id="stage-title" class="sr-only">成像画布</h2>
      <svg id="lens-svg" viewBox="0 0 900 420" role="img" aria-label="凸透镜成像画布">
        <defs>
          <linearGradient id="lensGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" stop-color="#a9e7ff" stop-opacity="0.9"></stop>
            <stop offset="50%" stop-color="#d7f4ff" stop-opacity="0.6"></stop>
            <stop offset="100%" stop-color="#a9e7ff" stop-opacity="0.9"></stop>
          </linearGradient>
          <marker id="arrowhead" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto" markerUnits="strokeWidth">
            <path d="M0,0 L6,3 L0,6 z" fill="currentColor"></path>
          </marker>
          <g id="sprite-candle">
            <rect x="-4" y="-60" width="8" height="60" fill="#1f7a3a"></rect>
            <path d="M0,-64 C-3,-68 3,-68 0,-64 Z" fill="#ffcc33"></path>
          </g>
          <g id="sprite-person">
            <circle cx="0" cy="-65" r="5" fill="#1f7a3a"></circle>
            <line x1="0" y1="-60" x2="0" y2="0" stroke="#1f7a3a" stroke-width="3"></line>
            <line x1="0" y1="-40" x2="-12" y2="-25" stroke="#1f7a3a" stroke-width="3"></line>
            <line x1="0" y1="-40" x2="12" y2="-25" stroke="#1f7a3a" stroke-width="3"></line>
          </g>
          <g id="sprite-arrow">
            <line x1="0" y1="0" x2="0" y2="-60" stroke="#1f7a3a" stroke-width="3" marker-end="url(#arrowhead)"></line>
          </g>
        </defs>
        <rect x="0" y="0" width="900" height="420" fill="transparent"></rect>
        <g id="rays"></g>
        <g id="objects"></g>
        <g id="lens">
          <path id="lens-shape" fill="url(#lensGrad)" fill-opacity="0.3" stroke="#3aa0ff" stroke-width="2"></path>
          <line id="lens-center-line" x1="450" y1="40" x2="450" y2="380" stroke="#3aa0ff" stroke-width="2" stroke-linecap="round" stroke-opacity="0.7"></line>
        </g>
        <g id="markers">
          <line id="principal-axis" x1="30" y1="210" x2="870" y2="210" stroke="#1c3d74" stroke-width="2" stroke-dasharray="4 4" opacity="0.6"></line>
          <g id="focus-markers" fill="none" stroke="#1c3d74" stroke-width="2" opacity="0.75">
            <line id="left-2f" x1="210" y1="190" x2="210" y2="230"></line>
            <text id="left-2f-label" x="210" y="252" text-anchor="middle" font-size="16" fill="#1c3d74">2F</text>
            <line id="left-f" x1="330" y1="190" x2="330" y2="230"></line>
            <text id="left-f-label" x="330" y="252" text-anchor="middle" font-size="16" fill="#1c3d74">F</text>
            <line id="right-f" x1="570" y1="190" x2="570" y2="230"></line>
            <text id="right-f-label" x="570" y="252" text-anchor="middle" font-size="16" fill="#1c3d74">F</text>
            <line id="right-2f" x1="690" y1="190" x2="690" y2="230"></line>
            <text id="right-2f-label" x="690" y="252" text-anchor="middle" font-size="16" fill="#1c3d74">2F</text>
          </g>
          <g id="screen-layer"></g>
          <g id="label-layer"></g>
        </g>
      </svg>
      <div id="stage-hud">
        <p id="mode-guide">探索模式：拖动滑块观察成像随参数的变化。</p>
        <p id="status-text" aria-live="polite">实时演示中：移动滑块观察成像规律。</p>
      </div>
      <div id="mode-ui"></div>
    </section>

    <aside id="info" aria-labelledby="info-title">
      <h2 id="info-title">信息面板</h2>
      <div class="info-card" aria-live="polite">
        <h3>当前参数</h3>
        <ul class="info-list">
          <li><span class="label">物距 u</span><span id="info-u">18.0 cm</span></li>
          <li><span class="label">焦距 f</span><span id="info-f">10.0 cm</span></li>
          <li><span class="label">物高 ho</span><span id="info-ho">3.0 cm</span></li>
          <li><span class="label">像距 v</span><span id="info-v">— cm</span></li>
          <li><span class="label">像高 hi</span><span id="info-hi">— cm</span></li>
          <li><span class="label">放大率 m</span><span id="info-m">—</span></li>
        </ul>
      </div>
      <div class="info-card" aria-live="polite">
        <h3>像的性质</h3>
        <p id="image-nature">
          <span class="badge" id="nature-type">待计算</span>
          <span id="orientation-text">—</span>
          <span id="scale-text">—</span>
        </p>
      </div>
      <div class="info-card">
        <h3>教学提示</h3>
        <p id="teaching-tip">观察不同物距下的像距与像的性质，尝试总结规律～</p>
      </div>
    </aside>
  </main>

  <footer>
    © 2025 教育科技实验演示
  </footer>

  <script>
    (() => {
      const today = new Date().toISOString().slice(0, 10);
      console.log(`[LensLab] Step3 build OK @${today}`);

      const SCALE = 12;
      const ORIGIN_X = 450;
      const AXIS_Y = 210;
      const MODES = ['explore', 'summary', 'challenge', 'quiz'];
      const SPRITES = ['candle', 'person', 'arrow'];
      const modePrompts = {
        explore: {
          hint: '拖动滑块看看会发生什么～',
          guide: '探索模式：拖动滑块观察成像随参数的变化。',
          badge: '探索模式'
        },
        summary: {
          hint: '对比不同物距区间的规律，试着总结一句话～',
          guide: '规律总结：观察表格，尝试口头描述成像规律。',
          badge: '规律总结'
        },
        challenge: {
          hint: '按照关卡要求调参，命中条件会提示成功。',
          guide: '挑战模式：满足目标条件即可通关，调节范围受容差影响。',
          badge: '挑战模式'
        },
        quiz: {
          hint: '作答后立即反馈，看看能否满分！',
          guide: '测验模式：完成判断、选择与计算题，立刻查看得分。',
          badge: '测验模式'
        }
      };

      const STORAGE_KEYS = {
        u: 'lenslab_u',
        f: 'lenslab_f',
        ho: 'lenslab_ho',
        showRays: 'lenslab_showRays',
        showScreen: 'lenslab_showScreen',
        teacherMode: 'lenslab_teacherMode',
        tolerance: 'lenslab_tol',
        mode: 'lenslab_mode',
        sprite: 'lenslab_sprite',
        challengeConfig: 'lenslab_challengeConfig',
        challengeState: 'lenslab_challengeStates',
        quizScore: 'lenslab_quizScore'
      };

      const state = {
        u: 18,
        f: 10,
        ho: 3,
        showRays: true,
        showScreen: false,
        teacherMode: false,
        tolerance: 0.5,
        mode: 'explore',
        sprite: 'candle',
        challenges: [],
        challengeStates: {},
        quizResults: {}
      };

      const supportsStorage = (() => {
        try {
          const key = '__lenslab_test__';
          window.localStorage.setItem(key, '1');
          window.localStorage.removeItem(key);
          return true;
        } catch (err) {
          console.warn('[LensLab] localStorage 不可用，使用默认参数');
          return false;
        }
      })();

      function clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }

      function formatNumber(value, digits = 1) {
        if (value === null || value === undefined || Number.isNaN(value)) {
          return '—';
        }
        return Number(value).toFixed(digits);
      }

      function persistState(key, value) {
        if (!supportsStorage || !Object.prototype.hasOwnProperty.call(STORAGE_KEYS, key)) return;
        if (typeof value === 'object') {
          window.localStorage.setItem(STORAGE_KEYS[key], JSON.stringify(value));
        } else {
          window.localStorage.setItem(STORAGE_KEYS[key], String(value));
        }
      }

      function loadPersistedState() {
        if (!supportsStorage) return;
        const savedU = parseFloat(window.localStorage.getItem(STORAGE_KEYS.u));
        const savedF = parseFloat(window.localStorage.getItem(STORAGE_KEYS.f));
        const savedHo = parseFloat(window.localStorage.getItem(STORAGE_KEYS.ho));
        const savedShowRays = window.localStorage.getItem(STORAGE_KEYS.showRays);
        const savedShowScreen = window.localStorage.getItem(STORAGE_KEYS.showScreen);
        const savedTeacher = window.localStorage.getItem(STORAGE_KEYS.teacherMode);
        const savedTol = parseFloat(window.localStorage.getItem(STORAGE_KEYS.tolerance));
        const savedMode = window.localStorage.getItem(STORAGE_KEYS.mode);
        const savedSprite = window.localStorage.getItem(STORAGE_KEYS.sprite);
        const savedChallengeConfig = window.localStorage.getItem(STORAGE_KEYS.challengeConfig);
        const savedChallengeState = window.localStorage.getItem(STORAGE_KEYS.challengeState);
        const savedQuizScore = window.localStorage.getItem(STORAGE_KEYS.quizScore);

        if (!Number.isNaN(savedU)) state.u = clamp(savedU, 5, 30);
        if (!Number.isNaN(savedF)) state.f = clamp(savedF, 5, 15);
        if (!Number.isNaN(savedHo)) state.ho = clamp(savedHo, 1, 5);
        if (savedShowRays !== null) state.showRays = savedShowRays === 'true';
        if (savedShowScreen !== null) state.showScreen = savedShowScreen === 'true';
        if (savedTeacher !== null) state.teacherMode = savedTeacher === 'true';
        if (!Number.isNaN(savedTol) && savedTol >= 0.1 && savedTol <= 1) state.tolerance = savedTol;
        if (savedMode && MODES.includes(savedMode)) state.mode = savedMode;
        if (savedSprite && SPRITES.includes(savedSprite)) state.sprite = savedSprite;

        if (savedChallengeConfig) {
          try {
            const parsed = JSON.parse(savedChallengeConfig);
            if (Array.isArray(parsed)) {
              state.challenges = parsed;
            }
          } catch (err) {
            console.warn('[LensLab] 解析挑战配置失败，已重置。', err);
          }
        }

        if (savedChallengeState) {
          try {
            const parsedState = JSON.parse(savedChallengeState);
            if (parsedState && typeof parsedState === 'object') {
              state.challengeStates = parsedState;
            }
          } catch (err) {
            console.warn('[LensLab] 解析挑战状态失败。', err);
          }
        }

        if (savedQuizScore) {
          try {
            const parsedScore = JSON.parse(savedQuizScore);
            if (parsedScore && typeof parsedScore === 'object') {
              state.quizResults = parsedScore;
            }
          } catch (err) {
            console.warn('[LensLab] 解析测验得分失败。', err);
          }
        }
      }

      loadPersistedState();

      const elements = {
        uRange: document.getElementById('u-range'),
        fRange: document.getElementById('f-range'),
        hoRange: document.getElementById('ho-range'),
        showRays: document.getElementById('show-rays'),
        showScreen: document.getElementById('show-screen'),
        teacherToggle: document.getElementById('teacher-mode-toggle'),
        tolRange: document.getElementById('tol-range'),
        spriteSelect: document.getElementById('spriteSelect'),
        uDisplay: document.getElementById('u-display'),
        fDisplay: document.getElementById('f-display'),
        hoDisplay: document.getElementById('ho-display'),
        tolDisplay: document.getElementById('tol-display'),
        infoU: document.getElementById('info-u'),
        infoF: document.getElementById('info-f'),
        infoHo: document.getElementById('info-ho'),
        infoV: document.getElementById('info-v'),
        infoHi: document.getElementById('info-hi'),
        infoM: document.getElementById('info-m'),
        natureType: document.getElementById('nature-type'),
        orientationText: document.getElementById('orientation-text'),
        scaleText: document.getElementById('scale-text'),
        teachingTip: document.getElementById('teaching-tip'),
        statusText: document.getElementById('status-text'),
        modeGuide: document.getElementById('mode-guide'),
        modeHint: document.getElementById('mode-hint'),
        stage: document.getElementById('stage-container'),
        modeUi: document.getElementById('mode-ui'),
        modeTabs: Array.from(document.querySelectorAll('.mode-tab')),
        raysGroup: document.getElementById('rays'),
        objectsGroup: document.getElementById('objects'),
        lensGroup: document.getElementById('lens'),
        markersGroup: document.getElementById('markers'),
        labelLayer: document.getElementById('label-layer'),
        screenLayer: document.getElementById('screen-layer'),
        focus: {
          leftF: document.getElementById('left-f'),
          leftFLabel: document.getElementById('left-f-label'),
          left2F: document.getElementById('left-2f'),
          left2FLabel: document.getElementById('left-2f-label'),
          rightF: document.getElementById('right-f'),
          rightFLabel: document.getElementById('right-f-label'),
          right2F: document.getElementById('right-2f'),
          right2FLabel: document.getElementById('right-2f-label')
        },
        lensShape: document.getElementById('lens-shape'),
        lensCenterLine: document.getElementById('lens-center-line'),
        selfTest: document.getElementById('self-test')
      };

      elements.uRange.value = state.u;
      elements.fRange.value = state.f;
      elements.hoRange.value = state.ho;
      elements.showRays.checked = state.showRays;
      elements.showScreen.checked = state.showScreen;
      elements.teacherToggle.checked = state.teacherMode;
      elements.tolRange.value = state.tolerance;
      elements.spriteSelect.value = state.sprite;
      elements.stage.dataset.modeLabel = modePrompts[state.mode].badge;
      document.body.classList.toggle('teacher-mode', state.teacherMode);

      let animationHandle = null;

      function scheduleUpdate() {
        if (animationHandle) {
          cancelAnimationFrame(animationHandle);
        }
        animationHandle = requestAnimationFrame(updateScene);
      }

      function setMarker(line, label, x) {
        line.setAttribute('x1', x);
        line.setAttribute('x2', x);
        label.setAttribute('x', x);
      }

      function setFocusMarkers(f) {
        const leftF = ORIGIN_X - f * SCALE;
        const rightF = ORIGIN_X + f * SCALE;
        const left2F = ORIGIN_X - 2 * f * SCALE;
        const right2F = ORIGIN_X + 2 * f * SCALE;
        setMarker(elements.focus.leftF, elements.focus.leftFLabel, leftF);
        setMarker(elements.focus.rightF, elements.focus.rightFLabel, rightF);
        setMarker(elements.focus.left2F, elements.focus.left2FLabel, left2F);
        setMarker(elements.focus.right2F, elements.focus.right2FLabel, right2F);
      }

      function computeLensThickness(f) {
        const minT = 6;
        const maxT = 22;
        const ratio = (clamp(f, 5, 15) - 5) / 10;
        return maxT - ratio * (maxT - minT);
      }

      function updateLensShape(f) {
        const thickness = computeLensThickness(f);
        const half = thickness / 2;
        const topY = AXIS_Y - 150;
        const bottomY = AXIS_Y + 150;
        const controlOffset = 110 + (22 - thickness) * 3;
        const leftX = ORIGIN_X - half;
        const rightX = ORIGIN_X + half;
        const pathData = `M ${leftX} ${topY} C ${leftX - controlOffset} ${AXIS_Y - 60}, ${leftX - controlOffset} ${AXIS_Y + 60}, ${leftX} ${bottomY} L ${rightX} ${bottomY} C ${rightX + controlOffset} ${AXIS_Y + 60}, ${rightX + controlOffset} ${AXIS_Y - 60}, ${rightX} ${topY} Z`;
        elements.lensShape.setAttribute('d', pathData);
        elements.lensCenterLine.setAttribute('x1', ORIGIN_X);
        elements.lensCenterLine.setAttribute('x2', ORIGIN_X);
      }

      function clearGroup(group) {
        while (group && group.firstChild) {
          group.removeChild(group.firstChild);
        }
      }

      function clearDynamicLayers() {
        clearGroup(elements.objectsGroup);
        clearGroup(elements.raysGroup);
        clearGroup(elements.labelLayer);
        clearGroup(elements.screenLayer);
      }

      function createLine(attrs) {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        Object.entries(attrs).forEach(([key, value]) => line.setAttribute(key, value));
        return line;
      }

      function createPolyline(points, attrs = {}) {
        const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
        polyline.setAttribute('points', points.map(pt => `${pt.x},${pt.y}`).join(' '));
        Object.entries(attrs).forEach(([key, value]) => polyline.setAttribute(key, value));
        return polyline;
      }

      function createText(x, y, content, attrs = {}) {
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', x);
        text.setAttribute('y', y);
        text.setAttribute('text-anchor', 'middle');
        text.textContent = content;
        Object.entries(attrs).forEach(([key, value]) => text.setAttribute(key, value));
        return text;
      }

      function createUse({ x, y, scaleX = 1, scaleY = 1, href, role }) {
        const use = document.createElementNS('http://www.w3.org/2000/svg', 'use');
        use.setAttribute('href', `#${href}`);
        use.setAttribute('transform', `translate(${x}, ${y}) scale(${scaleX}, ${scaleY})`);
        use.setAttribute('data-role', role);
        return use;
      }
      function renderObject(base, heightPx) {
        const spriteHeight = Math.max(Math.abs(heightPx), 1);
        const scale = spriteHeight / 60;
        const spriteId = `sprite-${state.sprite}`;
        const objectUse = createUse({
          x: base.x,
          y: base.y,
          scaleX: scale,
          scaleY: scale,
          href: spriteId,
          role: 'object'
        });
        elements.objectsGroup.appendChild(objectUse);
        const label = createText(base.x, base.y + 26, '物体', { fill: '#1f7a3a', 'font-size': '16', 'font-weight': '600' });
        elements.labelLayer.appendChild(label);
      }

      function renderImage(base, heightPx, v) {
        const isReal = v > 0;
        const color = isReal ? '#1e6ffb' : '#ff8a00';
        const spriteHeight = Math.max(Math.abs(heightPx), 1);
        const scale = spriteHeight / 60;
        const spriteId = `sprite-${state.sprite}`;
        const scaleY = (heightPx >= 0 ? 1 : -1) * scale;
        const imageUse = createUse({
          x: base.x,
          y: base.y,
          scaleX: scale,
          scaleY,
          href: spriteId,
          role: 'image'
        });
        imageUse.setAttribute('fill', color);
        imageUse.setAttribute('stroke', color);
        imageUse.setAttribute('stroke-width', '1.2');
        elements.objectsGroup.appendChild(imageUse);
        const labelY = heightPx < 0 ? base.y + 26 : base.y - spriteHeight - 12;
        const label = createText(base.x, labelY, '像', { fill: color, 'font-size': '16', 'font-weight': '600' });
        elements.labelLayer.appendChild(label);
      }

      function extendLine(pointA, pointB, targetX) {
        const slope = (pointB.y - pointA.y) / (pointB.x - pointA.x);
        const y = pointA.y + slope * (targetX - pointA.x);
        return { x: targetX, y };
      }

      function lineIntersection(p1, p2, x) {
        const t = (x - p1.x) / (p2.x - p1.x);
        const y = p1.y + t * (p2.y - p1.y);
        return { x, y };
      }

      function renderRayLabels(objectTip, lensParallelPoint, lensCenter, leftFocusPoint, imageTip, isReal) {
        if (!state.teacherMode) return;
        const mid = (a, b) => ({ x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 });
        const firstMid = mid(objectTip, lensParallelPoint);
        const secondMid = mid(objectTip, lensCenter);
        const thirdMid = mid(objectTip, leftFocusPoint);
        const label1 = createText(firstMid.x + 6, firstMid.y - 18, '①', { fill: '#1c3d74', 'font-weight': '700', 'font-size': '18' });
        const label2 = createText(secondMid.x + 10, secondMid.y - 18, '②', { fill: '#1c3d74', 'font-weight': '700', 'font-size': '18' });
        const label3 = createText(thirdMid.x, thirdMid.y - 18, '③', { fill: '#1c3d74', 'font-weight': '700', 'font-size': '18' });
        elements.labelLayer.appendChild(label1);
        elements.labelLayer.appendChild(label2);
        elements.labelLayer.appendChild(label3);

        if (!isReal) {
          const note = createText(imageTip.x + 40, imageTip.y - 12, '延长线观测', { fill: '#555', 'font-size': '14' });
          elements.labelLayer.appendChild(note);
        }
      }

      function renderRays(objectTip, v, f, imageTip) {
        const rayColor = '#1e6ffb';
        const opacity = 0.55;
        const leftFocus = { x: ORIGIN_X - f * SCALE, y: AXIS_Y };
        const rightFocus = { x: ORIGIN_X + f * SCALE, y: AXIS_Y };
        const lensParallelPoint = { x: ORIGIN_X, y: objectTip.y };
        const lensCenter = { x: ORIGIN_X, y: AXIS_Y };

        const ray1Points = [objectTip, lensParallelPoint];
        if (v > 0) {
          ray1Points.push(rightFocus, imageTip);
        } else {
          ray1Points.push(rightFocus, extendLine(rightFocus, imageTip, ORIGIN_X + 280));
        }
        const ray1 = createPolyline(ray1Points, {
          stroke: rayColor,
          'stroke-width': 2,
          'stroke-opacity': opacity,
          fill: 'none',
          'marker-end': 'url(#arrowhead)'
        });

        const slopeCenter = (lensCenter.y - objectTip.y) / (lensCenter.x - objectTip.x);
        const ray2Target = v > 0 ? imageTip : { x: ORIGIN_X + 280, y: lensCenter.y + slopeCenter * 280 };
        const ray2 = createPolyline([
          objectTip,
          lensCenter,
          ray2Target
        ], {
          stroke: rayColor,
          'stroke-width': 2,
          'stroke-opacity': opacity,
          fill: 'none',
          'marker-end': 'url(#arrowhead)'
        });

        const lensIntersectionForRay3 = lineIntersection(objectTip, leftFocus, ORIGIN_X);
        const ray3Target = v > 0 ? imageTip : { x: ORIGIN_X + 280, y: lensIntersectionForRay3.y };
        const ray3 = createPolyline([
          objectTip,
          lensIntersectionForRay3,
          ray3Target
        ], {
          stroke: rayColor,
          'stroke-width': 2,
          'stroke-opacity': opacity,
          fill: 'none',
          'marker-end': 'url(#arrowhead)'
        });

        elements.raysGroup.appendChild(ray1);
        elements.raysGroup.appendChild(ray2);
        elements.raysGroup.appendChild(ray3);

        if (v < 0) {
          const dashedAttrs = {
            stroke: rayColor,
            'stroke-width': 1.5,
            'stroke-opacity': 0.4,
            'stroke-dasharray': '6 6',
            fill: 'none'
          };
          const ray1Dash = createPolyline([lensParallelPoint, imageTip], dashedAttrs);
          const ray2Dash = createPolyline([lensCenter, imageTip], dashedAttrs);
          const ray3Dash = createPolyline([lensIntersectionForRay3, imageTip], dashedAttrs);
          elements.raysGroup.appendChild(ray1Dash);
          elements.raysGroup.appendChild(ray2Dash);
          elements.raysGroup.appendChild(ray3Dash);
        }

        renderRayLabels(objectTip, lensParallelPoint, lensCenter, lensIntersectionForRay3, imageTip, v > 0);
      }

      function setNoImageState() {
        elements.infoV.textContent = '— cm';
        elements.infoHi.textContent = '— cm';
        elements.infoM.textContent = '—';
        elements.natureType.textContent = '平行光，不成像';
        elements.natureType.className = 'badge';
        elements.orientationText.textContent = '—';
        elements.scaleText.textContent = '—';
        elements.statusText.textContent = '接近平行光，不成像（光线将保持平行）';
        elements.statusText.className = 'warning';
        elements.teachingTip.textContent = '当物体位于焦点位置时，凸透镜会让光线变成平行光，无法在屏幕上成像。稍微移动物距试试～';
      }

      function computeOutcome(u, f, ho) {
        if (Math.abs(u - f) < 0.1) {
          return { noImage: true };
        }
        const v = (f * u) / (u - f);
        const m = -v / u;
        const hi = m * ho;
        return { v, m, hi, noImage: false };
      }

      function updateInfoPanel({ v, m, hi }) {
        elements.infoV.textContent = `${formatNumber(v)} cm`;
        elements.infoHi.textContent = `${formatNumber(hi)} cm`;
        elements.infoM.textContent = formatNumber(m, 2);
        const isReal = v > 0;
        elements.natureType.textContent = isReal ? '实像' : '虚像';
        elements.natureType.className = `badge ${isReal ? 'real' : 'virtual'}`;
        const orientation = m < 0 ? '倒立' : '正立';
        const absM = Math.abs(m);
        let scaleText = '等大';
        if (absM > 1.05) {
          scaleText = '放大';
        } else if (absM < 0.95) {
          scaleText = '缩小';
        }
        elements.orientationText.textContent = `姿态：${orientation}`;
        elements.scaleText.textContent = `大小：${scaleText}`;
        elements.teachingTip.textContent = isReal
          ? '蓝色像表示实像，位于透镜右侧且常常倒立。试着改变物距观察放大率的变化！'
          : '橙色像表示虚像，与物体在同侧且正立放大，就像放大镜一样需要回看才能看到。';
      }

      function updateStatusMessage(result) {
        if (!result || result.noImage) {
          elements.statusText.textContent = '接近平行光，不成像（光线将保持平行）';
          elements.statusText.className = 'warning';
          return;
        }
        const { v } = result;
        const isReal = v > 0;
        elements.statusText.textContent = isReal
          ? '已成实像：透镜右侧可接收到倒立像。'
          : '形成虚像：需要从透镜左侧观察才能看到正立放大像。';
        elements.statusText.className = isReal ? 'positive' : '';
      }

      function drawScreen(x) {
        const screen = createLine({
          x1: x,
          y1: AXIS_Y - 170,
          x2: x,
          y2: AXIS_Y + 170,
          stroke: '#c6cdd7',
          'stroke-width': 3,
          'stroke-dasharray': '6 8'
        });
        elements.screenLayer.appendChild(screen);
      }

      function computeModeHtml() {
        if (state.mode === 'explore') {
          return `<div class="content" role="group"><p>拖动物距、焦距和物高，观察物体与像的相对位置变化。注意蓝色代表实像，橙色代表虚像。</p></div>`;
        }
        if (state.mode === 'summary') {
          return `<div class="content" role="group"><p>对比不同物距区间的成像结果：</p><table aria-label="凸透镜成像规律总结表"><thead><tr><th>物距区间</th><th>成像类型</th><th>像距范围</th><th>放大率</th><th>特点</th></tr></thead><tbody><tr><td>u &gt; 2f</td><td>实像</td><td>f &lt; v &lt; 2f</td><td>0 &lt; |m| &lt; 1</td><td>倒立缩小</td></tr><tr><td>u = 2f</td><td>实像</td><td>v = 2f</td><td>|m| = 1</td><td>倒立等大</td></tr><tr><td>f &lt; u &lt; 2f</td><td>实像</td><td>v &gt; 2f</td><td>|m| &gt; 1</td><td>倒立放大</td></tr><tr><td>u = f</td><td>—</td><td>—</td><td>—</td><td>平行光</td></tr><tr><td>u &lt; f</td><td>虚像</td><td>v &lt; 0</td><td>|m| &gt; 1</td><td>正立放大</td></tr></tbody></table></div>`;
        }
        if (state.mode === 'challenge') {
          return `<div class="content" role="group"><p id="challenge-tip">读题后再操作，达成条件会自动判定。</p><ul id="challenge-list" class="challenge-list"></ul><div class="challenge-actions"><button type="button" id="refresh-challenges">重新抽题</button><p id="challenge-feedback" aria-live="polite"></p></div></div>`;
        }
        return `<div class="content" role="group"><div class="quiz-question" data-question="q1" data-type="truefalse" data-answer="false"><h4>判断题</h4><p>当物距 u 小于焦距 f 时，屏幕上会得到一个实像。（对/错）</p><div class="quiz-options"><label><input type="radio" name="q1" value="true"> 对</label><label><input type="radio" name="q1" value="false"> 错</label></div><p class="quiz-feedback" aria-live="polite"></p></div><div class="quiz-question" data-question="q2" data-type="single" data-answer="等大倒立实像"><h4>单选题</h4><p>当物距 u = 2f 时，像的性质是什么？</p><div class="quiz-options"><label><input type="radio" name="q2" value="倒立缩小实像"> 倒立缩小实像</label><label><input type="radio" name="q2" value="等大倒立实像"> 等大倒立实像</label><label><input type="radio" name="q2" value="正立放大虚像"> 正立放大虚像</label></div><p class="quiz-feedback" aria-live="polite"></p></div><div class="quiz-question" data-question="q3" data-type="calculation" data-answer-v="30" data-answer-nature="倒立放大实像"><h4>计算题</h4><p>焦距 f = 10 cm，物距 u = 15 cm。请计算像距 v，并判断像的性质。</p><div class="quiz-options"><label>像距 v = <input type="number" class="quiz-input" step="0.1" data-field="v" aria-label="像距答案"> cm</label><label>像的性质<select class="quiz-input" data-field="nature" aria-label="像的性质答案"><option value="">请选择</option><option value="倒立放大实像">倒立放大实像</option><option value="倒立缩小实像">倒立缩小实像</option><option value="正立放大虚像">正立放大虚像</option></select></label></div><p class="quiz-feedback" aria-live="polite"></p></div><p id="quiz-score">本次得分：0 / 3</p><button type="button" id="quiz-reset">重做测验</button></div>`;
      }
      function renderModeContent() {
        elements.modeUi.innerHTML = computeModeHtml();
        elements.challengeList = document.getElementById('challenge-list');
        elements.challengeFeedback = document.getElementById('challenge-feedback');
        elements.refreshChallenges = document.getElementById('refresh-challenges');
        elements.quizQuestions = Array.from(document.querySelectorAll('#mode-ui .quiz-question'));
        elements.quizScore = document.getElementById('quiz-score');
        elements.quizReset = document.getElementById('quiz-reset');

        if (elements.refreshChallenges) {
          elements.refreshChallenges.addEventListener('click', () => {
            state.challenges = createChallengeSet();
            state.challengeStates = {};
            saveChallenges();
            renderChallenges();
            if (elements.challengeFeedback) {
              elements.challengeFeedback.textContent = '已重新抽题，祝你好运！';
            }
            scheduleUpdate();
          });
        }

        if (elements.quizReset) {
          elements.quizReset.addEventListener('click', resetQuiz);
        }

        if (state.mode === 'challenge') {
          renderChallenges();
        }

        if (state.mode === 'quiz') {
          initQuiz();
        }
      }

      function setMode(mode, { persist = true } = {}) {
        if (!MODES.includes(mode)) return;
        state.mode = mode;
        if (persist) {
          persistState('mode', mode);
        }
        updateModeUI();
      }

      function updateModeUI() {
        elements.modeTabs.forEach(tab => {
          const isActive = tab.dataset.mode === state.mode;
          tab.classList.toggle('active', isActive);
          tab.setAttribute('aria-selected', isActive ? 'true' : 'false');
          tab.setAttribute('tabindex', isActive ? '0' : '-1');
        });

        const prompt = modePrompts[state.mode];
        elements.modeHint.textContent = prompt.hint;
        elements.modeGuide.textContent = prompt.guide;
        elements.stage.dataset.modeLabel = prompt.badge;
        renderModeContent();
      }

      function createChallengeSet(existing = state.challenges) {
        const baseChallenges = [
          {
            id: 'challenge-a',
            title: '倒立放大实像',
            description: '使成像为倒立放大实像（v > 2f，u 介于 f 与 2f 之间）。',
            validate: result => !result.noImage && result.v > 2 * state.f && result.v > 0 && Math.abs(result.m) > 1 && result.m < 0
          },
          {
            id: 'challenge-b',
            title: '等大成像',
            description: '让物距接近 2f，像与物等大。',
            validate: result => !result.noImage && Math.abs(state.u - 2 * state.f) <= state.tolerance && Math.abs(Math.abs(result.m) - 1) <= 0.05
          },
          {
            id: 'challenge-c',
            title: '放大镜模式',
            description: '让物距小于焦距，出现正立放大虚像。',
            validate: result => result.v < 0 && result.m > 1.05
          }
        ];

        const extraChallenges = [
          {
            id: 'challenge-d',
            title: '缩小实像',
            description: '调节到 u > 2f，像距介于 f 和 2f 之间，像缩小。',
            validate: result => !result.noImage && state.u > 2 * state.f && result.v > state.f && result.v < 2 * state.f && Math.abs(result.m) < 1
          }
        ];

        if (!existing || existing.length === 0) {
          const pool = [...baseChallenges, ...extraChallenges];
          return pool.sort(() => Math.random() - 0.5).slice(0, 3);
        }
        return existing;
      }

      function saveChallenges() {
        persistState('challengeConfig', state.challenges);
        persistState('challengeState', state.challengeStates);
      }

      function renderChallenges() {
        if (!elements.challengeList) return;
        elements.challengeList.innerHTML = '';
        state.challenges.forEach(challenge => {
          const li = document.createElement('li');
          li.className = 'challenge-item';
          li.setAttribute('data-id', challenge.id);
          if (state.challengeStates[challenge.id]) {
            li.classList.add('passed');
          }
          li.innerHTML = `<h4>${challenge.title}</h4><p>${challenge.description}</p><p class="status">${state.challengeStates[challenge.id] ? '✅ 完成！' : '❌ 再试试～'}</p>`;
          elements.challengeList.appendChild(li);
        });
      }

      function evaluateChallenges(result) {
        if (!state.challenges.length) {
          state.challenges = createChallengeSet();
        }
        let changed = false;
        let lastUnlocked = '';
        state.challenges.forEach(challenge => {
          const pass = !result.noImage && challenge.validate(result);
          if (pass && !state.challengeStates[challenge.id]) {
            state.challengeStates[challenge.id] = true;
            changed = true;
            lastUnlocked = `${challenge.title} ✅ 完成！`;
          }
        });

        if (changed) {
          saveChallenges();
        }

        if (state.mode === 'challenge') {
          renderChallenges();
          if (elements.challengeFeedback) {
            if (changed) {
              elements.challengeFeedback.textContent = lastUnlocked || '恭喜完成挑战！';
            } else {
              const remaining = state.challenges.filter(ch => !state.challengeStates[ch.id]).length;
              elements.challengeFeedback.textContent = remaining === 0
                ? '全部关卡完成！可以尝试调整容差或重新抽题。'
                : `尚有 ${remaining} 关待完成，加油！`;
            }
          }
        }
      }

      function updateToleranceDisplay() {
        elements.tolDisplay.textContent = `±${formatNumber(state.tolerance, 1)} cm`;
      }

      function handleInputChange(event) {
        const { id, value, checked } = event.target;
        if (id === 'show-rays') {
          state.showRays = checked;
          persistState('showRays', checked);
        } else if (id === 'show-screen') {
          state.showScreen = checked;
          persistState('showScreen', checked);
        } else {
          const numericValue = parseFloat(value);
          if (id === 'u-range') {
            state.u = clamp(numericValue, 5, 30);
            persistState('u', state.u);
          }
          if (id === 'f-range') {
            state.f = clamp(numericValue, 5, 15);
            persistState('f', state.f);
          }
          if (id === 'ho-range') {
            state.ho = clamp(numericValue, 1, 5);
            persistState('ho', state.ho);
          }
        }
        scheduleUpdate();
      }
      function updateScene() {
        animationHandle = null;
        const u = clamp(parseFloat(elements.uRange.value), 5, 30);
        const f = clamp(parseFloat(elements.fRange.value), 5, 15);
        const ho = clamp(parseFloat(elements.hoRange.value), 1, 5);
        const showRays = elements.showRays.checked;
        const showScreen = elements.showScreen.checked;

        state.u = u;
        state.f = f;
        state.ho = ho;
        state.showRays = showRays;
        state.showScreen = showScreen;

        elements.uRange.value = u;
        elements.fRange.value = f;
        elements.hoRange.value = ho;

        elements.uDisplay.textContent = `${formatNumber(u)} cm`;
        elements.fDisplay.textContent = `${formatNumber(f)} cm`;
        elements.hoDisplay.textContent = `${formatNumber(ho)} cm`;

        elements.infoU.textContent = `${formatNumber(u)} cm`;
        elements.infoF.textContent = `${formatNumber(f)} cm`;
        elements.infoHo.textContent = `${formatNumber(ho)} cm`;

        updateLensShape(f);
        setFocusMarkers(f);
        clearDynamicLayers();

        if (Math.abs(u - f) < 0.1) {
          setNoImageState();
          evaluateChallenges({ noImage: true });
          return;
        }

        const result = computeOutcome(u, f, ho);
        const objectBase = { x: ORIGIN_X - u * SCALE, y: AXIS_Y };
        const objectHeightPx = ho * SCALE;
        const objectTip = { x: objectBase.x, y: AXIS_Y - objectHeightPx };
        const imageBase = { x: ORIGIN_X + result.v * SCALE, y: AXIS_Y };
        const imageHeightPx = result.hi * SCALE;
        const imageTip = { x: imageBase.x, y: AXIS_Y - imageHeightPx };

        renderObject(objectBase, objectHeightPx);
        renderImage(imageBase, imageHeightPx, result.v);

        if (showRays) {
          renderRays(objectTip, result.v, f, imageTip);
        }

        if (showScreen && result.v > 0) {
          drawScreen(imageBase.x);
        }

        updateInfoPanel(result);
        updateStatusMessage(result);
        evaluateChallenges(result);
      }

      function runSelfTest() {
        const cases = [
          {
            label: 'Case A',
            input: { u: 25, f: 10, ho: 3 },
            validator: ({ v, m }) => v > 16 && v < 17 && m < 0 && Math.abs(m) < 1,
            message: 'u=25,f=10 → 倒立缩小实像'
          },
          {
            label: 'Case B',
            input: { u: 20, f: 10, ho: 3 },
            validator: ({ v, m }) => Math.abs(v - 20) < 0.2 && Math.abs(Math.abs(m) - 1) < 0.05 && m < 0,
            message: 'u=20,f=10 → 等大倒立实像'
          },
          {
            label: 'Case C',
            input: { u: 15, f: 10, ho: 3 },
            validator: ({ v, m }) => v > 29 && Math.abs(m) > 1.9 && m < 0,
            message: 'u=15,f=10 → 倒立放大实像'
          },
          {
            label: 'Case D',
            input: { u: 10, f: 10, ho: 3 },
            validator: (result) => result.noImage,
            message: 'u=10,f=10 → 不成像'
          },
          {
            label: 'Case E',
            input: { u: 8, f: 10, ho: 3 },
            validator: ({ v, m }) => v < 0 && m > 1.2,
            message: 'u=8,f=10 → 正立放大虚像'
          }
        ];

        const summary = cases.map(testCase => {
          const result = computeOutcome(testCase.input.u, testCase.input.f, testCase.input.ho);
          const pass = result.noImage ? testCase.validator(result) : testCase.validator(result);
          const detail = result.noImage
            ? '不成像'
            : `v=${formatNumber(result.v)}cm, m=${formatNumber(result.m, 2)}`;
          console.log(`[自检] ${testCase.label}: ${pass ? '✅' : '❌'} ${testCase.message} ｜ 结果：${detail}`);
          return `${testCase.label}：${pass ? '✅' : '❌'} ${testCase.message}`;
        }).join('\n');

        window.alert(`自检完成：\n${summary}`);
      }

      function setQuizFeedback(questionEl, status, message) {
        const feedback = questionEl.querySelector('.quiz-feedback');
        if (!feedback) return;
        feedback.textContent = message;
        feedback.classList.remove('correct', 'incorrect');
        if (status === 'correct') {
          feedback.classList.add('correct');
        } else if (status === 'incorrect') {
          feedback.classList.add('incorrect');
        }
      }

      function updateQuizScore() {
        if (!elements.quizQuestions || !elements.quizScore) return;
        const total = elements.quizQuestions.length;
        const score = Object.values(state.quizResults).filter(value => value === true).length;
        elements.quizScore.textContent = `本次得分：${score} / ${total}`;
        persistState('quizScore', state.quizResults);
      }

      const quizExplanations = {
        q1: 'u < f 时形成正立放大虚像，因此该说法是错的。',
        q2: 'u = 2f 时，像距也约等于 2f，得到倒立等大的实像。',
        q3: '由 1/f = 1/u + 1/v 得 v = 30 cm，且 m = -v/u = -2，为倒立放大实像。'
      };

      function handleQuizChange(questionEl) {
        const type = questionEl.dataset.type;
        const id = questionEl.dataset.question;
        if (!id) return null;
        let result = null;
        if (type === 'truefalse' || type === 'single') {
          const selected = questionEl.querySelector('input[type="radio"]:checked');
          if (!selected) {
            setQuizFeedback(questionEl, null, '请选择一个选项。');
            state.quizResults[id] = null;
            updateQuizScore();
            return null;
          }
          const isCorrect = selected.value === questionEl.dataset.answer;
          state.quizResults[id] = isCorrect;
          setQuizFeedback(questionEl, isCorrect ? 'correct' : 'incorrect', isCorrect ? '✅ 回答正确！' : `❌ 再想想：${quizExplanations[id]}`);
          result = isCorrect;
        } else if (type === 'calculation') {
          const vInput = questionEl.querySelector('input[data-field="v"]');
          const natureSelect = questionEl.querySelector('select[data-field="nature"]');
          const vValue = parseFloat(vInput.value);
          const natureValue = natureSelect.value;
          if (Number.isNaN(vValue) || !natureValue) {
            setQuizFeedback(questionEl, null, '请填写完整的像距和性质。');
            state.quizResults[id] = null;
            updateQuizScore();
            return null;
          }
          const targetV = parseFloat(questionEl.dataset.answerV);
          const targetNature = questionEl.dataset.answerNature;
          const vOk = Math.abs(vValue - targetV) <= 0.2;
          const natureOk = natureValue === targetNature;
          const isCorrect = vOk && natureOk;
          state.quizResults[id] = isCorrect;
          setQuizFeedback(questionEl, isCorrect ? 'correct' : 'incorrect', isCorrect ? '✅ 计算正确！' : `❌ 请检查：${quizExplanations[id]}`);
          result = isCorrect;
        }
        updateQuizScore();
        return result;
      }

      function resetQuiz() {
        if (!elements.quizQuestions) return;
        elements.quizQuestions.forEach(question => {
          question.querySelectorAll('input[type="radio"]').forEach(input => {
            input.checked = false;
          });
          question.querySelectorAll('input[type="number"]').forEach(input => {
            input.value = '';
          });
          question.querySelectorAll('select').forEach(select => {
            select.value = '';
          });
          setQuizFeedback(question, null, '');
        });
        state.quizResults = {};
        updateQuizScore();
      }

      function initQuiz() {
        if (!elements.quizQuestions) return;
        elements.quizQuestions.forEach(question => {
          const controls = question.querySelectorAll('input, select');
          controls.forEach(control => {
            const handler = () => handleQuizChange(question);
            control.addEventListener('change', handler);
            if (control.type === 'number') {
              control.addEventListener('input', handler);
            }
          });
        });
        updateQuizScore();
        if (Object.keys(state.quizResults).length > 0) {
          elements.quizQuestions.forEach(question => {
            const id = question.dataset.question;
            const stored = state.quizResults[id];
            if (stored === true) {
              setQuizFeedback(question, 'correct', '✅ 上次回答正确，可继续挑战新题。');
            } else if (stored === false) {
              setQuizFeedback(question, 'incorrect', `❌ 上次未通过：${quizExplanations[id]}`);
            }
          });
        }
      }

      function runSelfCheck() {
        const checks = [];
        const originalMode = state.mode;
        const stageRectBefore = elements.stage.getBoundingClientRect();
        setMode('summary', { persist: false });
        const stageRectAfter = elements.stage.getBoundingClientRect();
        const stableStage = Math.abs(stageRectAfter.top - stageRectBefore.top) < 1;
        checks.push({ name: '画布高度稳定', pass: stableStage });
        setMode(originalMode, { persist: false });

        const modeUiHasContent = elements.modeUi.querySelector('.content') !== null;
        checks.push({ name: '模式内容位于画布内', pass: modeUiHasContent });

        const thick = computeLensThickness(5);
        const thin = computeLensThickness(15);
        checks.push({ name: '焦距影响透镜厚度', pass: thick - thin >= 12 });

        let spriteOk = true;
        const originalSprite = state.sprite;
        SPRITES.forEach(type => {
          state.sprite = type;
          elements.spriteSelect.value = type;
          updateScene();
          const objectUse = elements.objectsGroup.querySelector('use[data-role="object"]');
          const imageUse = elements.objectsGroup.querySelector('use[data-role="image"]');
          if (!objectUse || !imageUse) {
            spriteOk = false;
          }
        });
        state.sprite = originalSprite;
        elements.spriteSelect.value = originalSprite;
        scheduleUpdate();
        checks.push({ name: '物体图标切换', pass: spriteOk });

        updateScene();
        const ray = elements.raysGroup.querySelector('polyline');
        const opacity = ray ? parseFloat(ray.getAttribute('stroke-opacity') || ray.style.strokeOpacity || '1') : 1;
        checks.push({ name: '光线半透明', pass: opacity < 1 });

        const sample = computeOutcome(18, 10, 3);
        const physicsOk = Math.abs(sample.v - (10 * 18) / (18 - 10)) < 1e-6 && Math.abs(sample.m + sample.v / 18) < 1e-6;
        checks.push({ name: '物理公式一致', pass: physicsOk });

        checks.forEach(item => {
          console.log(`[SelfCheck] ${item.name}: ${item.pass ? 'PASS' : 'FAIL'}`);
        });
        console.log(`[LensLab] Final Build OK @${today}`);
      }

      elements.uRange.addEventListener('input', handleInputChange);
      elements.fRange.addEventListener('input', handleInputChange);
      elements.hoRange.addEventListener('input', handleInputChange);
      elements.showRays.addEventListener('input', handleInputChange);
      elements.showScreen.addEventListener('input', handleInputChange);

      elements.teacherToggle.addEventListener('change', event => {
        state.teacherMode = event.target.checked;
        document.body.classList.toggle('teacher-mode', state.teacherMode);
        persistState('teacherMode', state.teacherMode);
        scheduleUpdate();
      });

      elements.tolRange.addEventListener('input', event => {
        state.tolerance = clamp(parseFloat(event.target.value), 0.1, 1);
        persistState('tolerance', state.tolerance);
        updateToleranceDisplay();
        scheduleUpdate();
      });

      elements.spriteSelect.addEventListener('change', event => {
        const value = event.target.value;
        if (SPRITES.includes(value)) {
          state.sprite = value;
          persistState('sprite', value);
          scheduleUpdate();
        }
      });

      elements.modeTabs.forEach(tab => {
        tab.addEventListener('click', () => setMode(tab.dataset.mode));
        tab.addEventListener('keydown', event => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            setMode(tab.dataset.mode);
          }
        });
      });

      elements.selfTest.addEventListener('click', runSelfTest);

      if (window.location.hash.includes('dev')) {
        document.body.classList.add('dev-mode');
      }

      state.challenges = createChallengeSet(state.challenges);
      updateToleranceDisplay();
      updateModeUI();
      scheduleUpdate();
      runSelfCheck();
    })();
  </script>

  <!-- CHANGELOG 2025-02-14:
  Added vivid sprites, gradient convex lens, fixed layout shift,
  floating mode UI, and independent side scrolling. -->
</body>
</html>
