<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>凸透镜成像实验（Convex Lens Imaging）Step 2</title>
  <style>
    :root {
      color-scheme: light;
      --bg-color: #f7f8fa;
      --card-bg: #ffffff;
      --primary: #1c3d74;
      --primary-soft: rgba(28, 61, 116, 0.1);
      --text: #2a2a2a;
      --muted: #6c7a89;
      --real: #1c7ed6;
      --virtual: #f08c00;
      --danger: #d9480f;
      --success: #2b8a3e;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Segoe UI", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
      background: var(--bg-color);
      color: var(--text);
      line-height: 1.6;
      font-size: 16px;
    }

    header,
    footer {
      background: #ffffff;
      border-bottom: 1px solid rgba(28, 61, 116, 0.12);
      padding: 16px 24px;
      box-shadow: 0 2px 8px rgba(28, 61, 116, 0.08);
    }

    header h1 {
      margin: 0;
      font-size: 26px;
      color: var(--primary);
      letter-spacing: 0.5px;
    }

    main {
      display: grid;
      gap: 20px;
      padding: 20px 24px 32px;
      grid-template-columns: minmax(260px, 320px) 1fr minmax(260px, 320px);
      min-height: calc(100vh - 160px);
    }

    section {
      background: var(--card-bg);
      border-radius: 16px;
      box-shadow: 0 8px 24px rgba(28, 61, 116, 0.12);
      padding: 20px 24px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    #controls h2,
    #info h2 {
      margin: 0;
      font-size: 20px;
      color: var(--primary);
    }

    #controls .hint {
      margin: -4px 0 4px;
      color: var(--muted);
      font-size: 15px;
    }

    .control-item {
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 14px;
      border: 1px solid rgba(28, 61, 116, 0.12);
      border-radius: 12px;
      background: rgba(247, 248, 250, 0.7);
    }

    .control-item label {
      font-weight: 600;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 17px;
      gap: 12px;
    }

    .control-item output {
      min-width: 80px;
      text-align: right;
      font-variant-numeric: tabular-nums;
    }

    .control-item input[type="range"] {
      width: 100%;
      accent-color: var(--primary);
    }

    .helper {
      color: var(--muted);
      font-size: 14px;
    }

    .toggle-wrapper {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px;
      border: 1px solid rgba(28, 61, 116, 0.12);
      border-radius: 12px;
      background: rgba(247, 248, 250, 0.7);
      font-weight: 600;
      font-size: 17px;
      gap: 12px;
    }

    .switch {
      position: relative;
      width: 48px;
      height: 24px;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(28, 61, 116, 0.25);
      transition: 0.3s;
      border-radius: 24px;
    }

    .slider::before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 4px;
      bottom: 3px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    }

    .switch input:checked + .slider {
      background-color: rgba(28, 61, 116, 0.6);
    }

    .switch input:checked + .slider::before {
      transform: translateX(24px);
    }

    #stage {
      position: relative;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 24px;
    }

    #stage svg {
      width: 100%;
      max-width: 900px;
      height: auto;
      border-radius: 12px;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.95), rgba(235, 240, 250, 0.9));
      box-shadow: inset 0 0 0 1px rgba(28, 61, 116, 0.12);
    }

    #status-text {
      margin: 0;
      font-size: 18px;
      color: var(--muted);
    }

    #status-text.warning {
      color: var(--danger);
      font-weight: 600;
    }

    #status-text.positive {
      color: var(--success);
      font-weight: 600;
    }

    .info-card {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 16px;
      border-radius: 14px;
      background: rgba(255, 255, 255, 0.92);
      box-shadow: inset 0 0 0 1px rgba(28, 61, 116, 0.08);
    }

    .info-card h3 {
      margin: 0;
      font-size: 18px;
      color: var(--primary);
    }

    .info-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
      color: var(--text);
    }

    .info-list li {
      display: flex;
      justify-content: space-between;
      font-variant-numeric: tabular-nums;
      font-weight: 500;
    }

    .info-list li span.label {
      color: var(--muted);
      font-weight: 600;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 2px 10px;
      border-radius: 999px;
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 0.5px;
      background: var(--primary-soft);
      color: var(--primary);
      margin-right: 6px;
    }

    .badge.real {
      background: rgba(28, 126, 214, 0.15);
      color: var(--real);
    }

    .badge.virtual {
      background: rgba(240, 140, 0, 0.18);
      color: var(--virtual);
    }

    #result-summary {
      margin: 0;
      font-variant-numeric: tabular-nums;
    }

    #image-nature {
      margin: 0;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    #image-nature span {
      font-weight: 600;
    }

    footer {
      text-align: center;
      font-size: 15px;
      color: var(--muted);
      border-top: 1px solid rgba(28, 61, 116, 0.12);
      box-shadow: 0 -2px 8px rgba(28, 61, 116, 0.08);
    }

    .dev-only {
      display: none;
      border: 1px dashed rgba(28, 61, 116, 0.4);
      background: rgba(28, 61, 116, 0.06);
      color: var(--primary);
      padding: 10px 14px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
    }

    body.dev-mode .dev-only {
      display: inline-flex;
      align-self: flex-end;
    }

    @media (max-width: 1100px) {
      main {
        grid-template-columns: minmax(240px, 300px) 1fr;
        grid-template-areas:
          "controls stage"
          "info info";
      }

      #controls {
        grid-area: controls;
      }

      #stage {
        grid-area: stage;
      }

      #info {
        grid-area: info;
      }
    }

    @media (max-width: 768px) {
      main {
        grid-template-columns: 1fr;
      }

      section {
        padding: 18px;
      }

      header,
      footer {
        padding: 14px 18px;
      }

      header h1 {
        font-size: 24px;
      }

      body {
        font-size: 17px;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>凸透镜成像实验（Convex Lens Imaging）</h1>
  </header>

  <main>
    <section id="controls" aria-labelledby="controls-title">
      <h2 id="controls-title">调节区</h2>
      <p class="hint">拖动滑块看看会发生什么～</p>

      <div class="control-item">
        <label for="u-range"><span>物距 <strong>u</strong></span><output id="u-display" for="u-range">18.0 cm</output></label>
        <input id="u-range" type="range" min="5" max="30" step="0.1" value="18" aria-describedby="u-helper">
        <small id="u-helper" class="helper">范围：5–30 cm</small>
      </div>

      <div class="control-item">
        <label for="f-range"><span>焦距 <strong>f</strong></span><output id="f-display" for="f-range">10.0 cm</output></label>
        <input id="f-range" type="range" min="5" max="15" step="0.1" value="10" aria-describedby="f-helper">
        <small id="f-helper" class="helper">范围：5–15 cm</small>
      </div>

      <div class="control-item">
        <label for="ho-range"><span>物高 <strong>ho</strong></span><output id="ho-display" for="ho-range">3.0 cm</output></label>
        <input id="ho-range" type="range" min="1" max="5" step="0.1" value="3" aria-describedby="ho-helper">
        <small id="ho-helper" class="helper">范围：1–5 cm</small>
      </div>

      <div class="toggle-wrapper" role="group" aria-label="光线显示切换">
        <span>显示三条主光线</span>
        <label class="switch" aria-label="显示或隐藏光线">
          <input id="show-rays" type="checkbox" checked>
          <span class="slider" aria-hidden="true"></span>
        </label>
      </div>

      <button type="button" id="self-test" class="dev-only">运行自检（开发专用）</button>
    </section>

    <section id="stage" aria-labelledby="stage-title">
      <h2 id="stage-title">成像画布</h2>
      <svg id="lens-svg" viewBox="0 0 900 420" role="img" aria-label="凸透镜成像画布">
        <defs>
          <marker id="arrow-head" markerWidth="10" markerHeight="10" refX="8" refY="5" orient="auto" markerUnits="strokeWidth">
            <path d="M0,0 L10,5 L0,10 z" fill="currentColor"></path>
          </marker>
          <marker id="ray-arrow" markerWidth="10" markerHeight="10" refX="8" refY="5" orient="auto" markerUnits="strokeWidth">
            <path d="M0,0 L10,5 L0,10 z" fill="currentColor"></path>
          </marker>
        </defs>
        <rect x="0" y="0" width="900" height="420" fill="url(#stage-bg)" fill-opacity="0"></rect>
        <line x1="30" y1="210" x2="870" y2="210" stroke="#1c3d74" stroke-width="2" stroke-dasharray="4 4" opacity="0.6"></line>
        <line x1="450" y1="40" x2="450" y2="380" stroke="#1c3d74" stroke-width="4" stroke-linecap="round" opacity="0.8"></line>
        <g id="focus-markers" fill="none" stroke="#1c3d74" stroke-width="2" opacity="0.7">
          <line id="left-2f" x1="210" y1="190" x2="210" y2="230"></line>
          <text id="left-2f-label" x="210" y="250" text-anchor="middle" font-size="16" fill="#1c3d74">2F</text>
          <line id="left-f" x1="330" y1="190" x2="330" y2="230"></line>
          <text id="left-f-label" x="330" y="250" text-anchor="middle" font-size="16" fill="#1c3d74">F</text>
          <line id="right-f" x1="570" y1="190" x2="570" y2="230"></line>
          <text id="right-f-label" x="570" y="250" text-anchor="middle" font-size="16" fill="#1c3d74">F</text>
          <line id="right-2f" x1="690" y1="190" x2="690" y2="230"></line>
          <text id="right-2f-label" x="690" y="250" text-anchor="middle" font-size="16" fill="#1c3d74">2F</text>
        </g>
        <g id="objects"></g>
        <g id="rays"></g>
      </svg>
      <p id="status-text" aria-live="polite">实时演示中：移动滑块观察成像规律。</p>
    </section>

    <section id="info" aria-labelledby="info-title">
      <h2 id="info-title">信息面板</h2>
      <div class="info-card" aria-live="polite">
        <h3>当前参数</h3>
        <ul class="info-list">
          <li><span class="label">物距 u</span><span id="info-u">18.0 cm</span></li>
          <li><span class="label">焦距 f</span><span id="info-f">10.0 cm</span></li>
          <li><span class="label">物高 ho</span><span id="info-ho">3.0 cm</span></li>
        </ul>
      </div>
      <div class="info-card" aria-live="polite">
        <h3>成像结果</h3>
        <p id="result-summary">像距 v：__ cm｜放大率 m：__｜像高 hi：__ cm</p>
        <p id="image-nature">
          <span class="badge" id="nature-type">待计算</span>
          <span id="orientation-text">—</span>
          <span id="scale-text">—</span>
        </p>
      </div>
      <div class="info-card">
        <h3>教学提示</h3>
        <p id="teaching-tip">观察不同物距下的像距与像的性质，尝试总结规律～</p>
      </div>
    </section>
  </main>

  <footer>
    © 2025 教育科技实验演示
  </footer>

  <script>
    (() => {
      const today = new Date().toISOString().slice(0, 10);
      console.log(`[LensLab] Step2 build OK @${today}`);

      const SCALE = 12; // cm -> px
      const ORIGIN_X = 450;
      const AXIS_Y = 210;
      const STORAGE_KEYS = {
        u: 'lenslab_u',
        f: 'lenslab_f',
        ho: 'lenslab_ho',
        showRays: 'lenslab_showRays'
      };

      const state = {
        u: 18,
        f: 10,
        ho: 3,
        showRays: true
      };

      const supportsStorage = (() => {
        try {
          const testKey = '__lenslab_test__';
          window.localStorage.setItem(testKey, '1');
          window.localStorage.removeItem(testKey);
          return true;
        } catch (err) {
          console.warn('[LensLab] localStorage 不可用，使用默认参数');
          return false;
        }
      })();

      function loadPersistedState() {
        if (!supportsStorage) return;
        const savedU = parseFloat(window.localStorage.getItem(STORAGE_KEYS.u));
        const savedF = parseFloat(window.localStorage.getItem(STORAGE_KEYS.f));
        const savedHo = parseFloat(window.localStorage.getItem(STORAGE_KEYS.ho));
        const savedShowRays = window.localStorage.getItem(STORAGE_KEYS.showRays);
        if (!Number.isNaN(savedU)) state.u = clamp(savedU, 5, 30);
        if (!Number.isNaN(savedF)) state.f = clamp(savedF, 5, 15);
        if (!Number.isNaN(savedHo)) state.ho = clamp(savedHo, 1, 5);
        if (savedShowRays !== null) state.showRays = savedShowRays === 'true';
      }

      function persistState(key, value) {
        if (!supportsStorage) return;
        window.localStorage.setItem(STORAGE_KEYS[key], String(value));
      }

      loadPersistedState();

      const elements = {
        uRange: document.getElementById('u-range'),
        fRange: document.getElementById('f-range'),
        hoRange: document.getElementById('ho-range'),
        showRays: document.getElementById('show-rays'),
        uDisplay: document.getElementById('u-display'),
        fDisplay: document.getElementById('f-display'),
        hoDisplay: document.getElementById('ho-display'),
        infoU: document.getElementById('info-u'),
        infoF: document.getElementById('info-f'),
        infoHo: document.getElementById('info-ho'),
        resultSummary: document.getElementById('result-summary'),
        natureType: document.getElementById('nature-type'),
        orientationText: document.getElementById('orientation-text'),
        scaleText: document.getElementById('scale-text'),
        teachingTip: document.getElementById('teaching-tip'),
        statusText: document.getElementById('status-text'),
        objectsGroup: document.getElementById('objects'),
        raysGroup: document.getElementById('rays'),
        focus: {
          leftF: document.getElementById('left-f'),
          leftFLabel: document.getElementById('left-f-label'),
          left2F: document.getElementById('left-2f'),
          left2FLabel: document.getElementById('left-2f-label'),
          rightF: document.getElementById('right-f'),
          rightFLabel: document.getElementById('right-f-label'),
          right2F: document.getElementById('right-2f'),
          right2FLabel: document.getElementById('right-2f-label')
        },
        selfTest: document.getElementById('self-test')
      };

      elements.uRange.value = state.u;
      elements.fRange.value = state.f;
      elements.hoRange.value = state.ho;
      elements.showRays.checked = state.showRays;

      let animationHandle = null;

      function scheduleUpdate() {
        if (animationHandle) {
          cancelAnimationFrame(animationHandle);
        }
        animationHandle = requestAnimationFrame(updateScene);
      }

      function clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }

      function formatNumber(value, digits = 1) {
        return Number(value).toFixed(digits);
      }

      function setFocusMarkers(f) {
        const leftF = ORIGIN_X - f * SCALE;
        const rightF = ORIGIN_X + f * SCALE;
        const left2F = ORIGIN_X - 2 * f * SCALE;
        const right2F = ORIGIN_X + 2 * f * SCALE;

        setMarker(elements.focus.leftF, elements.focus.leftFLabel, leftF);
        setMarker(elements.focus.rightF, elements.focus.rightFLabel, rightF);
        setMarker(elements.focus.left2F, elements.focus.left2FLabel, left2F);
        setMarker(elements.focus.right2F, elements.focus.right2FLabel, right2F);
      }

      function setMarker(line, label, x) {
        line.setAttribute('x1', x);
        line.setAttribute('x2', x);
        label.setAttribute('x', x);
      }

      function clearGroups() {
        elements.objectsGroup.innerHTML = '';
        elements.raysGroup.innerHTML = '';
      }

      function createLine(attrs) {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        Object.entries(attrs).forEach(([key, value]) => line.setAttribute(key, value));
        return line;
      }

      function createPolyline(points, attrs = {}) {
        const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
        polyline.setAttribute('points', points.map(point => `${point.x},${point.y}`).join(' '));
        Object.entries(attrs).forEach(([key, value]) => polyline.setAttribute(key, value));
        return polyline;
      }

      function updateScene() {
        animationHandle = null;
        const u = clamp(parseFloat(elements.uRange.value), 5, 30);
        const f = clamp(parseFloat(elements.fRange.value), 5, 15);
        const ho = clamp(parseFloat(elements.hoRange.value), 1, 5);
        const showRays = elements.showRays.checked;

        state.u = u;
        state.f = f;
        state.ho = ho;
        state.showRays = showRays;

        elements.uRange.value = u;
        elements.fRange.value = f;
        elements.hoRange.value = ho;

        elements.uDisplay.textContent = `${formatNumber(u)} cm`;
        elements.fDisplay.textContent = `${formatNumber(f)} cm`;
        elements.hoDisplay.textContent = `${formatNumber(ho)} cm`;

        elements.infoU.textContent = `${formatNumber(u)} cm`;
        elements.infoF.textContent = `${formatNumber(f)} cm`;
        elements.infoHo.textContent = `${formatNumber(ho)} cm`;

        setFocusMarkers(f);
        clearGroups();

        if (Math.abs(u - f) < 0.1) {
          setNoImageState();
          return;
        }

        const v = (f * u) / (u - f);
        const m = v / u;
        const hi = m * ho;

        const objectBase = { x: ORIGIN_X - u * SCALE, y: AXIS_Y };
        const objectTip = { x: objectBase.x, y: AXIS_Y - ho * SCALE };
        const imageBase = { x: ORIGIN_X + v * SCALE, y: AXIS_Y };
        const imageTip = { x: imageBase.x, y: AXIS_Y - hi * SCALE };

        renderObject(objectBase, objectTip);
        renderImage(imageBase, imageTip, v);

        if (showRays) {
          renderRays(objectTip, v, f, imageTip);
        }

        updateInfoPanel({ v, m, hi });
        updateStatusMessage(v, m);
      }

      function setNoImageState() {
        elements.resultSummary.textContent = '像距 v：—｜放大率 m：—｜像高 hi：—';
        elements.natureType.textContent = '平行光，不成像';
        elements.natureType.className = 'badge';
        elements.orientationText.textContent = '—';
        elements.scaleText.textContent = '—';
        elements.statusText.textContent = '接近平行光，不成像（光线将保持平行）';
        elements.statusText.className = 'warning';
        elements.teachingTip.textContent = '当物体位于焦点位置时，凸透镜会让光线变成平行光，无法在屏幕上成像。稍微移动物距试试～';
      }

      function renderObject(base, tip) {
        const objectLine = createLine({
          x1: base.x,
          y1: base.y,
          x2: tip.x,
          y2: tip.y,
          stroke: '#1c3d74',
          'stroke-width': 4,
          'stroke-linecap': 'round',
          'marker-end': 'url(#arrow-head)'
        });
        const baseLine = createLine({
          x1: base.x - 8,
          y1: base.y,
          x2: base.x + 8,
          y2: base.y,
          stroke: '#1c3d74',
          'stroke-width': 3,
          'stroke-linecap': 'round'
        });
        elements.objectsGroup.appendChild(objectLine);
        elements.objectsGroup.appendChild(baseLine);
      }

      function renderImage(base, tip, v) {
        const isReal = v > 0;
        const color = isReal ? '#1c7ed6' : '#f08c00';
        const imageLine = createLine({
          x1: base.x,
          y1: base.y,
          x2: tip.x,
          y2: tip.y,
          stroke: color,
          'stroke-width': 4,
          'stroke-linecap': 'round',
          'marker-end': 'url(#arrow-head)'
        });
        const baseLine = createLine({
          x1: base.x - 8,
          y1: base.y,
          x2: base.x + 8,
          y2: base.y,
          stroke: color,
          'stroke-width': 3,
          'stroke-linecap': 'round'
        });
        elements.objectsGroup.appendChild(imageLine);
        elements.objectsGroup.appendChild(baseLine);
      }

      function renderRays(objectTip, v, f, imageTip) {
        const isReal = v > 0;
        const rayColor = isReal ? '#1c7ed6' : '#f08c00';
        const leftFocus = { x: ORIGIN_X - f * SCALE, y: AXIS_Y };
        const rightFocus = { x: ORIGIN_X + f * SCALE, y: AXIS_Y };
        const lensParallelPoint = { x: ORIGIN_X, y: objectTip.y };
        const lensCenter = { x: ORIGIN_X, y: AXIS_Y };

        const ray1Points = [objectTip, lensParallelPoint, rightFocus];
        if (isReal) {
          ray1Points.push(imageTip);
        } else {
          ray1Points.push(extendLine(lensParallelPoint, rightFocus, ORIGIN_X + 260));
        }
        const ray1 = createPolyline(ray1Points, {
          stroke: rayColor,
          'stroke-width': 2.5,
          fill: 'none',
          'marker-end': 'url(#ray-arrow)'
        });

        const slopeCenter = (lensCenter.y - objectTip.y) / (lensCenter.x - objectTip.x);
        const ray2Target = isReal
          ? imageTip
          : { x: ORIGIN_X + 260, y: lensCenter.y + slopeCenter * 260 };
        const ray2 = createPolyline([
          objectTip,
          lensCenter,
          ray2Target
        ], {
          stroke: rayColor,
          'stroke-width': 2.5,
          fill: 'none',
          'marker-end': 'url(#ray-arrow)'
        });

        const lensIntersectionForRay3 = lineIntersection(objectTip, leftFocus, ORIGIN_X);
        const ray3Target = isReal
          ? imageTip
          : { x: ORIGIN_X + 260, y: lensIntersectionForRay3.y };
        const ray3 = createPolyline([
          objectTip,
          lensIntersectionForRay3,
          ray3Target
        ], {
          stroke: rayColor,
          'stroke-width': 2.5,
          fill: 'none',
          'marker-end': 'url(#ray-arrow)'
        });

        elements.raysGroup.appendChild(ray1);
        elements.raysGroup.appendChild(ray2);
        elements.raysGroup.appendChild(ray3);

        if (!isReal) {
          const dashedAttrs = {
            stroke: rayColor,
            'stroke-width': 1.5,
            'stroke-dasharray': '6 6',
            fill: 'none'
          };

          const ray1Dash = createPolyline([
            lensParallelPoint,
            imageTip
          ], dashedAttrs);

          const ray2Dash = createPolyline([
            lensCenter,
            imageTip
          ], dashedAttrs);

          const ray3Dash = createPolyline([
            lensIntersectionForRay3,
            imageTip
          ], dashedAttrs);

          elements.raysGroup.appendChild(ray1Dash);
          elements.raysGroup.appendChild(ray2Dash);
          elements.raysGroup.appendChild(ray3Dash);
        }
      }

      function lineIntersection(p1, p2, x) {
        const t = (x - p1.x) / (p2.x - p1.x);
        const y = p1.y + t * (p2.y - p1.y);
        return { x, y };
      }

      function extendLine(pointA, pointB, targetX) {
        const slope = (pointB.y - pointA.y) / (pointB.x - pointA.x);
        const y = pointA.y + slope * (targetX - pointA.x);
        return { x: targetX, y };
      }

      function updateInfoPanel({ v, m, hi }) {
        elements.resultSummary.textContent = `像距 v：${formatNumber(v)} cm｜放大率 m：${formatNumber(m)}｜像高 hi：${formatNumber(hi)} cm`;
        const isReal = v > 0;
        elements.natureType.textContent = isReal ? '实像' : '虚像';
        elements.natureType.className = `badge ${isReal ? 'real' : 'virtual'}`;
        const orientation = m < 0 ? '倒立' : '正立';
        const absM = Math.abs(m);
        let scaleText = '等大';
        if (absM > 1.05) {
          scaleText = '放大';
        } else if (absM < 0.95) {
          scaleText = '缩小';
        }
        elements.orientationText.textContent = `姿态：${orientation}`;
        elements.scaleText.textContent = `大小：${scaleText}`;
        elements.teachingTip.textContent = isReal
          ? '蓝色像条表示实像，注意像位于透镜另一侧时往往伴随倒立。试着改变物距观察放大率变化！'
          : '橙色像条表示虚像。虚像会与物在同侧且正立放大，就像放大镜观察一样。';
      }

      function updateStatusMessage(v, m) {
        const isReal = v > 0;
        elements.statusText.textContent = isReal
          ? '已成实像：透镜右侧可以接到清晰倒立像。'
          : '形成虚像：需要从透镜左侧回看才能看到放大的正立像。';
        elements.statusText.className = isReal ? 'positive' : '';
      }

      function handleInputChange(event) {
        const { id, value, checked } = event.target;
        if (id === 'show-rays') {
          state.showRays = checked;
          persistState('showRays', checked);
        } else {
          const numericValue = parseFloat(value);
          if (id === 'u-range') {
            state.u = clamp(numericValue, 5, 30);
            persistState('u', state.u);
          }
          if (id === 'f-range') {
            state.f = clamp(numericValue, 5, 15);
            persistState('f', state.f);
          }
          if (id === 'ho-range') {
            state.ho = clamp(numericValue, 1, 5);
            persistState('ho', state.ho);
          }
        }
        scheduleUpdate();
      }

      function computeOutcome(u, f, ho) {
        if (Math.abs(u - f) < 0.1) {
          return { noImage: true };
        }
        const v = (f * u) / (u - f);
        const m = v / u;
        const hi = m * ho;
        return { v, m, hi, noImage: false };
      }

      function runSelfTest() {
        const cases = [
          {
            label: 'Case A',
            input: { u: 25, f: 10, ho: 3 },
            validator: ({ v, m }) => v > 10 && v < 30 && m < 0,
            message: 'u=25,f=10 → 应为倒立缩小实像'
          },
          {
            label: 'Case B',
            input: { u: 20, f: 10, ho: 3 },
            validator: ({ v, m }) => Math.abs(v - 20) < 0.1 && Math.abs(Math.abs(m) - 1) < 0.01,
            message: 'u=20,f=10 → 像距20cm，等大倒立'
          },
          {
            label: 'Case C',
            input: { u: 15, f: 10, ho: 3 },
            validator: ({ v, m }) => v > 20 && Math.abs(m) > 1,
            message: 'u=15,f=10 → 倒立放大实像'
          },
          {
            label: 'Case D',
            input: { u: 10, f: 10, ho: 3 },
            validator: (result) => result.noImage,
            message: 'u=10,f=10 → 不成像'
          },
          {
            label: 'Case E',
            input: { u: 8, f: 10, ho: 3 },
            validator: ({ v, m }) => v < 0 && m > 0,
            message: 'u=8,f=10 → 虚像正立放大'
          }
        ];

        const summary = cases.map(testCase => {
          const result = computeOutcome(testCase.input.u, testCase.input.f, testCase.input.ho);
          const pass = result.noImage ? testCase.validator(result) : testCase.validator(result);
          const detail = result.noImage
            ? '不成像'
            : `v=${formatNumber(result.v)}cm, m=${formatNumber(result.m, 2)}`;
          console.log(`[自检] ${testCase.label}: ${pass ? '✅' : '❌'} ${testCase.message} ｜ 结果：${detail}`);
          return `${testCase.label}：${pass ? '✅' : '❌'} ${testCase.message}`;
        }).join('\n');

        window.alert(`自检完成：\n${summary}`);
      }

      elements.uRange.addEventListener('input', handleInputChange);
      elements.fRange.addEventListener('input', handleInputChange);
      elements.hoRange.addEventListener('input', handleInputChange);
      elements.showRays.addEventListener('input', handleInputChange);
      elements.selfTest.addEventListener('click', runSelfTest);

      if (window.location.hash.includes('dev')) {
        document.body.classList.add('dev-mode');
      }

      scheduleUpdate();
    })();
  </script>
</body>
</html>
